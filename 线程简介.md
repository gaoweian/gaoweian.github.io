# 线程
## 线程基础
### 1）什么是进程
* 进程就是在某种程度上相互隔离的、独立运行的程序。
### 2）什么是线程
* 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。
* 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 
* 有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。
* 进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。
* Java 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。
## 每个 Java 程序都使用线程
*  每个 Java 程序都至少有一个线程 ― 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。
*  JVM 还创建了其它线程，您通常都看不到它们 ― 例如，与垃圾收集、对象终止和其它 JVM 内务处理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method Invocation））。
## 为什么使用线程？
* 在 Java 程序中使用线程有许多原因。如果您使用 Swing、servlet、RMI 或 Enterprise JavaBeans（EJB）技术，您也许没有意识到您已经在使用线程了。
使用线程的一些原因是它们可以帮助： 
    * 使 UI 响应更快
    * 利用多处理器系统
    * 简化建模
    * 执行异步或后台处理
## 特点
* 在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。
##### 1）轻型实体
* 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。
* 线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：
    * （1）线程状态。
    * （2）当线程不运行时，被保存的现场资源。
    * （3）一组执行堆栈。
    * （4）存放每个线程的局部变量主存区。
    * （5）访问同一个进程中的主存和其它资源。
* 用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。
##### 2）独立调度和分派的基本单位。
* 在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。
##### 3）可并发执行。
* 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。
##### 4）共享进程资源。
* 在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。
### 3）创建线程的方法
* 一、继承Thread类创建线程类
    * （1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    * （2）创建Thread子类的实例，即创建了线程对象。
    * （3）调用线程对象的start()方法来启动该线程。
###### 代码如下：
```
public class FirstThreadTest extends Thread{  
    int i = 0;  
    //重写run方法，run方法的方法体就是现场执行体  
    public void run()  
    {  
        for(;i<100;i++){  
        System.out.println(getName()+"  "+i);  
          
        }  
    }  
    public static void main(String[] args)  
    {  
        for(int i = 0;i< 100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+"  : "+i);  
            if(i==20)  
            {  
                new FirstThreadTest().start();  
                new FirstThreadTest().start();  
            }  
        }  
    }  
  
}  
上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。

```
####二、通过Runnable接口创建线程类

* （1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

* （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

* （3）调用线程对象的start()方法来启动该线程。
#######代码如下：
```
public class RunnableThreadTest implements Runnable  
{  
  
    private int i;  
    public void run()  
    {  
        for(i = 0;i <100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+" "+i);  
        }  
    }  
    public static void main(String[] args)  
    {  
        for(int i = 0;i < 100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+" "+i);  
            if(i==20)  
            {  
                RunnableThreadTest rtt = new RunnableThreadTest();  
                new Thread(rtt,"新线程1").start();  
                new Thread(rtt,"新线程2").start();  
            }  
        }  
  
    }  
  
}
```
#### 三、通过Callable和Future创建线程

* （1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
* （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
* （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。
* （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

###### 实例代码：
```
package com.thread;  
  
import java.util.concurrent.Callable;  
import java.util.concurrent.ExecutionException;  
import java.util.concurrent.FutureTask;  
  
public class CallableThreadTest implements Callable<Integer>  
{  
  
    public static void main(String[] args)  
    {  
        CallableThreadTest ctt = new CallableThreadTest();  
        FutureTask<Integer> ft = new FutureTask<>(ctt);  
        for(int i = 0;i < 100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i);  
            if(i==20)  
            {  
                new Thread(ft,"有返回值的线程").start();  
            }  
        }  
        try  
        {  
            System.out.println("子线程的返回值："+ft.get());  
        } catch (InterruptedException e)  
        {  
            e.printStackTrace();  
        } catch (ExecutionException e)  
        {  
            e.printStackTrace();  
        }  
  
    }  
  
    @Override  
    public Integer call() throws Exception  
    {  
        int i = 0;  
        for(;i<100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+" "+i);  
        }  
        return i;  
    }  
  
} 
```
### 二、创建线程的三种方式的对比

* 采用实现Runnable、Callable接口的方式创见多线程时，优势是：

    * 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

    * 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

* 劣势是：

    * 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

* 使用继承Thread类的方式创建多线程时优势是：

    * 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

* 劣势是：

    * 线程类已经继承了Thread类，所以不能再继承其他父类。


## 4)线程如何使用

* java平台从开始就被设计成为多线程环境。在你的主程序执行的时候，其它作业如碎片收集和事件处理则是在后台进行的。本质上，你可以认为这些作业是线程。它们正好是系统治理线程，但是无论如何，它们是线程。线程使你能够定义相互独立的作业，彼此之间互不干扰。系统将交换这些作业进或出CPU，这样（从外部看来）它们好象是同时运行的。 在你需要在你的程序中处理多个作业时，你也可以使用多个进程。这些进程可以是你自己创建的，你也可以操纵系统线程。 你进行这些多作业处理，要使用几个不同的类或接口： java.util.Timer类
* javax.swing.Timer类Thread类Runnable接口 对于简单的作业，通常需要重复的，你可以使用java.util.Timer类告诉它“每半秒钟做一次”。注重：大多数系统例程是使用毫秒的。半秒钟是500毫秒。 你希望Timer实现的任务是在java.util.TimerTask实例中定义的，其中运行的方法包含要执行的任务。这些在Hi类中进行了演示，其中字符串“Hi”重复地被显示在屏幕上，直到你按Enter键。
```
import java.util.*;
public class Hi {
    public static void main(String args[])
    throws java.io.IOException {
    TimerTask task = new TimerTask() {
        public void run() {
            System.out.PRintln("Hi");}};
    Timer timer = new Timer();
    timer.schedule(task, 0, 500);
    System.out.println("Press ENTER to stop");
    System.in.read(new byte[10]);
    timer.cancel();
    }
}
```
*  Java Runtime Environment工作的方式是只要有一个线程在运行，程序就不退出。这样，当取消被调用，没有其它线程在运行了，则程序退出。有一些系统线程在运行，如碎片收集程序。这些系统线程也被称为后台线程。后台线程的存在不影响运行环境被关闭，只有非后台线程保证运行环境不被关闭。 Javax.swing.Timer类与java.util.timer类的工作方式相似，但是有一些差别需要注重。第一，运行的作业被ActionListener接口的实现来定义。第二，作业的执行是在事件处理线程内部进行的，而不象java.util.Timer类是在它的外部。这是很重要的，因为它关系到Swing组件集是如何设计的。 假如你不熟悉Swing，它是一组可以被Java程序使用的图形组件。Swing被设计程被称为单线程的。这意味着对Swing类内部内容的访问必须在单个线程中完成。这个特定的线程是事件处理线程。这样，例如你想改变Label组件的文字，你不能仅仅调用Jlabel的setText方法。相反，你必须确认setText调用发生在事件处理线程中，而这正是javax.swing.Time类派的上用场的地方。 为了说明这第二种情况，下面的程序显示一个增加的计数器的值。美半秒钟计数器的数值增加，并且新的数值被显示。
## 5)线程的生命周期
* 1、新建状态
    * 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。
    * 注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。
* 2、就绪状态
    * 处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。
    * 提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。
* 3、运行状态
    * 处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
    * 处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。

    * 当发生如下情况是，线程会从运行状态变为阻塞状态：
        * ①、线程调用sleep方法主动放弃所占用的系统资源
        * ②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
        * ③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有
        * ④、线程在等待某个通知（notify）
        * ⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。

    *当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。
* 4、阻塞状态
    * 处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 
    * 在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。有三种方法可以暂停Threads执行：
* 5、死亡状态
    * 当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。